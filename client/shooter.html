<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Shooter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e27;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(100vh - 120px); /* Leave space for toolbar */
        }
        @media (max-width: 768px) and (orientation: portrait) {
            canvas {
                height: calc(100vh - 100px); /* Smaller toolbar in portrait */
            }
        }
        /* Bottom Toolbar */
        #toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: linear-gradient(to top, rgba(10, 14, 39, 0.95), rgba(10, 14, 39, 0.8));
            border-top: 3px solid rgba(0, 255, 136, 0.3);
            display: none; /* Hidden until game starts */
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }

        /* Player Info Section */
        .player-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }
        .player-name {
            color: #00ff88;
            font-size: 18px;
            font-weight: bold;
        }
        .health-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s;
        }
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .armor-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .armor-fill {
            height: 100%;
            background: linear-gradient(90deg, #4488ff, #66aaff);
            transition: width 0.3s;
        }
        .armor-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .stamina-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 14px;
            border-radius: 7px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            margin-top: 5px;
        }
        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f 0%, #f39c12 100%);
            transition: width 0.1s ease-out;
        }
        .stamina-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Toolbelt Section */
        .toolbelt {
            display: flex;
            gap: 10px;
            margin: 0 auto;
        }
        .tool-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .tool-slot:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-3px);
        }
        .tool-slot.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        .tool-icon {
            font-size: 28px;
        }
        .tool-key {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        .tool-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 2px;
        }

        /* Stats Section */
        .stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
            text-align: right;
        }
        .stat-item {
            color: white;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        .stat-icon {
            font-size: 18px;
        }
        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid #00ff88;
            color: white;
            text-align: center;
            min-width: 400px;
        }
        #menu h1 { color: #00ff88; margin-bottom: 20px; }
        #menu input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #1a1e3a;
            border: 2px solid #00ff88;
            color: white;
            border-radius: 6px;
            font-size: 16px;
        }
        #menu button {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #00ff88;
            border: none;
            color: #0a0e27;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        #menu button:hover { background: #00dd77; }
        .color-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
        }
        .color-btn.selected { border-color: white; }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1001; /* Above toolbar */
        }
        .mobile-joystick {
            position: fixed;
            bottom: 130px; /* Just above the 120px toolbar */
            left: 15%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            pointer-events: auto;
        }
        /* Portrait mode - smaller controls */
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-joystick {
                bottom: 110px; /* Just above the 100px toolbar */
                left: 15%;
                width: 90px;
                height: 90px;
            }
        }
        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            position: absolute;
        }
        .joystick-stick {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.6);
            border: 3px solid rgba(0, 255, 136, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .joystick-stick {
                width: 40px;
                height: 40px;
            }
        }
        .mobile-aim-joystick {
            position: fixed;
            bottom: 130px; /* Just above the 120px toolbar */
            right: 15%;
            transform: translateX(50%);
            width: 100px;
            height: 100px;
            pointer-events: auto;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-aim-joystick {
                bottom: 110px; /* Just above the 100px toolbar */
                right: 15%;
                width: 90px;
                height: 90px;
            }
        }
        .mobile-interact-btn {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border: 3px solid #fff;
            color: white;
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            z-index: 1002;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        .mobile-interact-btn:active {
            background: linear-gradient(135deg, #00cc66, #00aa55);
            transform: translateX(-50%) scale(0.95);
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-interact-btn {
                bottom: 110px;
            }
        }
        @media (max-width: 768px), (pointer: coarse) {
            #controls { display: none !important; }
        }
        /* Compact toolbar for portrait mode */
        @media (max-width: 768px) and (orientation: portrait) {
            #toolbar {
                height: 100px;
                padding: 0 10px;
            }
            .player-info {
                min-width: 140px;
                gap: 4px;
            }
            .player-name {
                font-size: 14px;
            }
            .health-bar {
                height: 18px;
            }
            .armor-bar {
                height: 14px;
            }
            .stamina-bar {
                height: 10px;
            }
            .mobile-joystick {
                bottom: 110px;
            }
            .mobile-shoot-area {
                bottom: 100px;
                height: calc(100vh - 100px);
            }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="mobile-joystick" id="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
        <div class="mobile-aim-joystick" id="aimJoystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="aimJoystickStick"></div>
        </div>
        <button class="mobile-interact-btn" id="mobileInteractBtn" style="display: none;">
            <span id="interactText">E</span>
        </button>
    </div>

    <!-- Bottom Toolbar -->
    <div id="toolbar">
        <!-- Left: Player Info -->
        <div class="player-info">
            <div class="player-name" id="playerName">Player</div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%;"></div>
                <div class="health-text" id="healthText">100/100</div>
            </div>
            <div class="armor-bar">
                <div class="armor-fill" id="armorFill" style="width: 0%;"></div>
                <div class="armor-text" id="armorText">0/100</div>
            </div>
            <div class="stamina-bar">
                <div class="stamina-fill" id="staminaFill" style="width: 100%;"></div>
                <div class="stamina-text" id="staminaText">100</div>
            </div>
        </div>

        <!-- Center: Toolbelt -->
        <div class="toolbelt">
            <div class="tool-slot" id="slot1" onclick="selectTool(1)">
                <div class="tool-key">1</div>
                <div class="tool-icon">🔨</div>
                <div class="tool-label">Hammer</div>
            </div>
            <div class="tool-slot active" id="slot2" onclick="selectTool(2)">
                <div class="tool-key">2</div>
                <div class="tool-icon">🔫</div>
                <div class="tool-label" id="weaponLabel">Pistol</div>
            </div>
            <div class="tool-slot" id="slot3" onclick="selectTool(3)">
                <div class="tool-key">3</div>
                <div class="tool-icon">🔧</div>
                <div class="tool-label">Repair</div>
            </div>
        </div>

        <!-- Right: Stats -->
        <div class="stats">
            <div class="stat-item">
                <span>Scrap:</span>
                <span class="stat-icon">⚙️</span>
                <span class="stat-value" id="scrapCount">0</span>
            </div>
            <div class="stat-item">
                <span>Ammo:</span>
                <span class="stat-icon">📦</span>
                <span class="stat-value" id="ammoCount">∞</span>
            </div>
            <div class="stat-item">
                <span>Ability:</span>
                <span class="stat-value" id="abilityName">None</span>
            </div>
            <div class="stat-item" id="pcIcon" onclick="openTerminal()" style="cursor: pointer; display: none;" title="Building Terminal">
                <span class="stat-icon" style="font-size: 24px;">💻</span>
            </div>
        </div>
    </div>

    <!-- Old-school Terminal Popup -->
    <div id="terminalPopup" style="display: none;">
        <div id="terminalContent">
            <div id="terminalHeader">
                <span>BUILDING TERMINAL v1.0</span>
                <button onclick="closeTerminal()" style="float: right;">X</button>
            </div>
            <div id="terminalBody">
                <div id="terminalText"></div>
            </div>
            <div id="terminalButtons"></div>
        </div>
    </div>

    <div id="menu">
        <h1>🎯 MULTIPLAYER SHOOTER</h1>
        <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />

        <div style="margin: 15px 0; color: #00ff88; font-weight: bold;">Choose Color:</div>
        <div class="color-picker" id="colorPicker"></div>

        <div style="margin: 20px 0; color: #00ff88; font-weight: bold;">Select Server:</div>
        <div id="serverButtons" style="display: flex; flex-direction: column; gap: 10px;"></div>

        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #333;">
            <input type="text" id="customServerInput" placeholder="Or enter custom URL (wss://...)" />
            <button onclick="connectCustom()" style="margin-top: 10px;">Connect to Custom Server</button>
        </div>
    </div>

    <script type="module">
        // Import utility modules (Phase 1 refactoring)
        import * as Constants from './js/utils/constants.js';
        import * as MathUtils from './js/utils/math.js';
        import * as Helpers from './js/utils/helpers.js';

        // Import rendering modules (Phase 2 refactoring)
        import { Renderer } from './js/rendering/Renderer.js';

        // Import network module (Phase 3 refactoring)
        import { NetworkManager } from './js/core/NetworkManager.js';

        // Import game systems (Phase 4 refactoring)
        import { PlayerController } from './js/systems/PlayerController.js';
        import { WeaponSystem } from './js/systems/WeaponSystem.js';
        import { AbilitySystem } from './js/systems/AbilitySystem.js';
        import { PhysicsSystem } from './js/systems/PhysicsSystem.js';
        import { ParticleSystem } from './js/systems/ParticleSystem.js';

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Initialize main renderer (Phase 2 refactoring)
        const renderer = new Renderer(ctx, canvas);

        // Set canvas size (leave space for toolbar)
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            // Account for toolbar height
            const isPortrait = window.innerHeight > window.innerWidth && window.innerWidth <= 768;
            const toolbarHeight = isPortrait ? 100 : 120;
            canvas.height = window.innerHeight - toolbarHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Map size (100m = 5000px) - Using constants from module
        const MAP_WIDTH = Constants.MAP_WIDTH;
        const MAP_HEIGHT = Constants.MAP_HEIGHT;

        // Game state
        const network = new NetworkManager();
        let playerId = null;
        let players = {};
        let bullets = [];
        let pickups = [];
        let obstacles = [];
        let myPlayer = null;

        // Terrain and block types
        let terrain = [];
        let floors = [];
        let buildings = []; // Building capture zones

        // Initialize game systems (Phase 4 refactoring)
        const particleSystem = new ParticleSystem();
        const playerController = new PlayerController(canvas, network);
        const weaponSystem = new WeaponSystem(network);
        const abilitySystem = new AbilitySystem(network);
        const physicsSystem = new PhysicsSystem(network, particleSystem);


        // FPS tracking
        let fps = 60;
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let fpsUpdateTime = Date.now();

        // Ping tracking
        let ping = 0;
        let pingStart = 0;
        let pingUpdateInterval = null;

        // Config with localStorage persistence
        let persistentPlayerId = localStorage.getItem('shooterPlayerId');
        if (!persistentPlayerId) {
            persistentPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('shooterPlayerId', persistentPlayerId);
        }

        let playerName = localStorage.getItem('shooterPlayerName') || '';
        let playerColor = localStorage.getItem('shooterPlayerColor') || '#4ecdc4';

        const colors = ['#4ecdc4', '#ff6b6b', '#95e1d3', '#f38181', '#aa96da', '#fcbad3',
                       '#a8d8ea', '#ffffd2', '#ffd93d', '#6bcf7f', '#ff8c42', '#c779d0'];

        // Setup color picker
        const colorPicker = document.getElementById('colorPicker');
        colors.forEach(color => {
            const btn = document.createElement('div');
            btn.className = 'color-btn';
            btn.style.background = color;
            btn.onclick = () => {
                playerColor = color;
                localStorage.setItem('shooterPlayerColor', color);
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            };
            if (color === playerColor) btn.classList.add('selected');
            colorPicker.appendChild(btn);
        });

        // Pre-fill name input with saved name
        if (playerName) {
            document.getElementById('nameInput').value = playerName;
        }

        // Auto-detect server URL based on how page was accessed
        let autoServerUrl = null;
        const currentHost = window.location.host;
        const isLocalhost = currentHost.includes('localhost') || currentHost.includes('127.0.0.1');

        if (!isLocalhost) {
            // Accessed via public URL - auto-connect to same host's WebSocket
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            autoServerUrl = `${protocol}//${currentHost}`;
            console.log('Public access detected, will auto-connect to:', autoServerUrl);
        }

        // Available servers for manual selection (only shown for localhost)
        const availableServers = [
            { name: '🏠 Local Server', url: 'ws://localhost:3001', type: 'local' },
        ];

        // Load tunnel URL if available (for localhost users)
        let tunnelUrl = null;

        // Render immediately if public URL
        if (autoServerUrl) {
            renderServerButtons();
        } else {
            // Otherwise fetch tunnel URL for localhost users
            fetch('./server-url.json')
                .then(res => res.json())
                .then(data => {
                    tunnelUrl = data.url;
                    availableServers.push({ name: '🌐 Public Tunnel', url: tunnelUrl, type: 'tunnel' });
                    renderServerButtons();
                })
                .catch((err) => {
                    console.log('No tunnel URL found (this is OK if running locally)');
                    renderServerButtons();
                });
        }

        function renderServerButtons() {
            const container = document.getElementById('serverButtons');
            container.innerHTML = '';

            // If accessed via public URL, show single "Start Game" button
            if (autoServerUrl) {
                const btn = document.createElement('button');
                btn.textContent = '🎮 START GAME';
                btn.style.background = '#00ff88';
                btn.style.color = '#0a0e27';
                btn.style.fontSize = '20px';
                btn.style.padding = '15px 30px';
                btn.style.fontWeight = 'bold';
                btn.onclick = () => startGame(autoServerUrl);
                container.appendChild(btn);
                return;
            }

            // Otherwise show server selection for localhost users
            availableServers.forEach(server => {
                const btn = document.createElement('button');
                btn.textContent = server.name + ' - ' + server.url;
                btn.style.background = server.type === 'tunnel' ? '#00ff88' : '#1a2040';
                btn.style.color = server.type === 'tunnel' ? '#0a0e27' : 'white';
                btn.onclick = () => startGame(server.url);
                container.appendChild(btn);
            });
        }

        // Start game
        function startGame(serverUrl) {
            if (!serverUrl) {
                alert('Please select a server or enter a custom URL');
                return;
            }

            playerName = document.getElementById('nameInput').value.trim() || 'Player';
            localStorage.setItem('shooterPlayerName', playerName);

            document.getElementById('menu').style.display = 'none';
            document.getElementById('toolbar').style.display = 'flex';
            document.getElementById('playerName').textContent = playerName;

            // Show mobile controls if on mobile
            if (playerController.isMobile) {
                document.querySelector('.mobile-controls').style.display = 'block';
            }

            connectToServer(serverUrl);
        }

        // Tool selection function (delegates to WeaponSystem)
        // Make it global so onclick handlers can access it
        window.selectTool = function(slot) {
            weaponSystem.selectTool(slot);
        }

        // Update UI function
        function updateUI() {
            if (!myPlayer) return;

            // Update health bar
            const healthPercent = (myPlayer.health / myPlayer.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = myPlayer.health + '/' + myPlayer.maxHealth;

            // Update armor bar
            const armorPercent = (myPlayer.armor / myPlayer.maxArmor) * 100;
            document.getElementById('armorFill').style.width = armorPercent + '%';
            document.getElementById('armorText').textContent = myPlayer.armor + '/' + myPlayer.maxArmor;

            // Update stamina bar
            const staminaPercent = (myPlayer.stamina / myPlayer.maxStamina) * 100;
            document.getElementById('staminaFill').style.width = staminaPercent + '%';
            document.getElementById('staminaText').textContent = Math.round(myPlayer.stamina);

            // Update scrap
            document.getElementById('scrapCount').textContent = myPlayer.scrap || 0;

            // Update ammo (uses WeaponSystem)
            const currentAmmo = weaponSystem.getCurrentAmmo();
            document.getElementById('ammoCount').textContent = currentAmmo === Infinity ? '∞' : currentAmmo;

            // Update weapon label (uses WeaponSystem)
            const currentWeapon = weaponSystem.getCurrentWeapon();
            if (currentWeapon && Constants.WEAPONS[currentWeapon]) {
                document.getElementById('weaponLabel').textContent = Constants.WEAPONS[currentWeapon].name;
            }
        }

        function connectCustom() {
            const url = document.getElementById('customServerInput').value.trim();

            if (!url) {
                alert('Please enter a server URL');
                return;
            }

            if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                alert('Server URL must start with ws:// or wss://');
                return;
            }

            startGame(url);
        }

        function connectToServer(url) {
            network.connect(url);

            // Setup connection handler
            network.onOpen(() => {
                console.log('Connection opened');

                // Send persistent player ID immediately
                network.send('register', {
                    persistentId: persistentPlayerId,
                    name: playerName,
                    color: playerColor
                });

                // Start ping measurement
                pingUpdateInterval = setInterval(() => {
                    if (network.isConnected()) {
                        pingStart = Date.now();
                        network.send('ping');
                    }
                }, 1000); // Measure ping every second
            });

            // Register message handlers
            network.on('init', (data) => {
                playerId = data.playerId;
                console.log('🎮 Player initialized:', playerId);

                // Use server position
                const serverPlayer = data.players.find(p => p.id === data.playerId);
                console.log('📍 Spawn position:', serverPlayer ? `(${Math.round(serverPlayer.x)}, ${Math.round(serverPlayer.y)})` : 'default');

                myPlayer = {
                    id: data.playerId,
                    name: playerName,
                    x: serverPlayer ? serverPlayer.x : canvas.width / 2,
                    y: serverPlayer ? serverPlayer.y : canvas.height / 2,
                    angle: 0,
                    health: 100,
                    maxHealth: 100,
                    armor: 0,
                    maxArmor: 100,
                    color: playerColor,
                    weapon: 'pistol',
                    scrap: 0,
                    stamina: 100,
                    maxStamina: 100,
                    invulnerable: true,
                    invulnerableUntil: Date.now() + 1500
                };
                players[playerId] = myPlayer;

                // Initialize game systems with player reference (Phase 4)
                playerController.setPlayer(myPlayer, playerId);
                weaponSystem.setPlayer(myPlayer, playerId);
                abilitySystem.setPlayer(myPlayer, playerId);
                physicsSystem.setPlayer(myPlayer, playerId);

                // Add other players
                data.players.forEach(p => {
                    if (p.id !== playerId) {
                        players[p.id] = p;
                    }
                });

                console.log('👥 Total players:', Object.keys(players).length);

                // Send name update
                network.send('updateName', { name: playerName });

                document.getElementById('playerName').textContent = playerName;
            });

            network.on('playerJoined', (data) => {
                players[data.player.id] = data.player;
                updatePlayerCount();
            });

            network.on('playerLeft', (data) => {
                delete players[data.playerId];
                updatePlayerCount();
            });

            network.on('playerMoved', (data) => {
                if (players[data.playerId] && data.playerId !== playerId) {
                    const player = players[data.playerId];

                    // Store target position for interpolation
                    player.targetX = data.x;
                    player.targetY = data.y;
                    player.targetAngle = data.angle;

                    // Initialize if first update
                    if (player.x === undefined) {
                        player.x = data.x;
                        player.y = data.y;
                    }
                }
            });

            network.on('playerShot', (data) => {
                // Don't add bullets we already created locally
                if (data.playerId === playerId) {
                    return; // Skip our own bullets echoed from server
                }

                bullets.push({
                    id: data.bulletId,
                    x: data.x,
                    y: data.y,
                    vx: data.vx,
                    vy: data.vy,
                    playerId: data.playerId,
                    damage: data.damage || 20,
                    size: data.size || 5,
                    color: data.color || '#ffeb3b',
                    explosive: data.explosive || false,
                    explosionRadius: data.explosionRadius,
                    penetration: data.penetration
                });
            });

            network.on('playerNameChanged', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].name = data.name;
                }
            });

            network.on('playerDamaged', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].health = data.health;
                    if (data.playerId === playerId && myPlayer) {
                        myPlayer.health = data.health;
                    }
                }
            });

            network.on('playerDied', (data) => {
                console.log('Player died:', data.playerId);
                // Create explosion at player location (uses ParticleSystem)
                if (players[data.playerId]) {
                    const player = players[data.playerId];
                    particleSystem.createDeathParticles(player.x, player.y, player.color);
                }
            });

            network.on('playerRespawned', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].x = data.x;
                    players[data.playerId].y = data.y;
                    players[data.playerId].health = data.health;
                    players[data.playerId].invulnerable = true;
                    players[data.playerId].invulnerableUntil = Date.now() + 1500;

                    if (data.playerId === playerId) {
                        myPlayer.x = data.x;
                        myPlayer.y = data.y;
                        myPlayer.health = data.health;
                        myPlayer.invulnerable = true;
                        myPlayer.invulnerableUntil = Date.now() + 1500;
                        weaponSystem.switchWeapon('pistol');
                    }
                }
            });

            network.on('pickupsUpdate', (data) => {
                pickups = data.pickups;
                console.log('📦 Received', pickups.length, 'pickups');
            });

            network.on('obstaclesUpdate', (data) => {
                obstacles = data.obstacles;
                console.log(`Received ${obstacles.length} obstacles from server`);
            });

            network.on('doorToggled', (data) => {
                // Handle multiple door blocks (3-block wide doors)
                const doorIds = data.doorIds || [data.doorId]; // Support both old and new format
                doorIds.forEach(doorId => {
                    const door = obstacles.find(o => o.id === doorId);
                    if (door) {
                        door.isOpen = data.isOpen;
                    }
                });
                console.log(`${doorIds.length} door block(s) toggled: ${data.isOpen ? 'open' : 'closed'}`);
            });

            network.on('terrainUpdate', (data) => {
                terrain = data.terrain;
                console.log(`Received ${terrain.length} terrain tiles from server`);
            });

            network.on('floorsUpdate', (data) => {
                floors = data.floors;
                console.log(`Received ${floors.length} floor tiles from server`);
            });

            network.on('buildingsUpdate', (data) => {
                buildings = data.buildings;
                console.log(`Received ${buildings.length} buildings from server`);
            });

            network.on('buildingCaptured', (data) => {
                const capturedBuilding = buildings.find(b => b.id === data.buildingId);
                if (capturedBuilding) {
                    capturedBuilding.ownerId = data.ownerId;
                    capturedBuilding.ownerName = data.ownerName;
                    console.log(`${data.ownerName} captured ${data.buildingId}!`);
                }
            });

            network.on('buildingNeutralized', (data) => {
                const neutralBuilding = buildings.find(b => b.id === data.buildingId);
                if (neutralBuilding) {
                    neutralBuilding.ownerId = null;
                    neutralBuilding.ownerName = null;
                }
            });

            network.on('buildingLost', (data) => {
                const lostBuilding = buildings.find(b => b.id === data.buildingId);
                if (lostBuilding) {
                    lostBuilding.ownerId = null;
                    lostBuilding.ownerName = null;
                }
            });

            network.on('buildingCaptureProgress', (data) => {
                const progressBuilding = buildings.find(b => b.id === data.buildingId);
                if (progressBuilding) {
                    if (!progressBuilding.captureProgress) progressBuilding.captureProgress = {};
                    progressBuilding.captureProgress[data.playerId] = data.progress;
                    progressBuilding.ownerId = data.ownerId;
                }
            });

            network.on('obstacleDestroyed', (data) => {
                // Convert obstacle to debris instead of removing it
                const destroyedObs = obstacles.find(o => o.id === data.obstacleId);
                if (destroyedObs && data.isDebris) {
                    // Convert to debris (walkable rubble)
                    destroyedObs.isDestroyed = true;
                    destroyedObs.isWall = false;
                    destroyedObs.health = 0;
                    destroyedObs.originalType = destroyedObs.blockType; // Store original type
                    destroyedObs.blockType = 'debris';
                } else if (destroyedObs) {
                    // Legacy: remove if not debris
                    obstacles = obstacles.filter(o => o.id !== data.obstacleId);
                }

                // Create small voxel debris particles (uses ParticleSystem)
                const centerX = data.x + data.width / 2;
                const centerY = data.y + data.height / 2;
                particleSystem.createDebrisParticles(centerX, centerY, 8);
            });

            network.on('obstacleDamaged', (data) => {
                // Update obstacle health
                const damagedObs = obstacles.find(o => o.id === data.obstacleId);
                if (damagedObs) {
                    damagedObs.health = data.health;
                }
            });

            network.on('pong', (data) => {
                if (pingStart > 0) {
                    ping = Date.now() - pingStart;
                    pingStart = 0;
                }
            });

            network.on('pickupCollected', (data) => {
                // Remove pickup
                pickups = pickups.filter(p => p.id !== data.pickupId);

                if (data.playerId === playerId) {
                    if (data.pickupType === 'health') {
                        myPlayer.health = Math.min(myPlayer.maxHealth, myPlayer.health + 30);
                    } else if (data.pickupType === 'armor') {
                        myPlayer.armor = Math.min(myPlayer.maxArmor, myPlayer.armor + 50);
                    } else if (data.pickupType.startsWith('weapon_')) {
                        const weaponType = data.pickupType.replace('weapon_', '');
                        weaponSystem.switchWeapon(weaponType);
                    }
                }
            });

            network.on('playerArmorUpdate', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].armor = data.armor;
                    if (data.playerId === playerId && myPlayer) {
                        myPlayer.armor = data.armor;
                    }
                }
            });

            network.on('playerScrapUpdate', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].scrap = data.scrap;
                    if (data.playerId === playerId && myPlayer) {
                        myPlayer.scrap = data.scrap;
                    }
                }
            });

            // Setup close handler
            network.onClose(() => {
                console.log('Disconnected from server');
            });
        }


        function updatePlayerCount() {
            document.getElementById('playerCount').textContent = Object.keys(players).length;
        }

        // Building/Door/Terminal interaction handlers (E and T keys)
        // Note: Other input handling is now in PlayerController, WeaponSystem, and AbilitySystem
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Terminal interaction with 'T' key
            if (key === 't') {
                const ownedBuilding = buildings.find(b => {
                    if (b.ownerId === playerId && b.terminal && myPlayer) {
                        const dist = Math.hypot(myPlayer.x - b.terminal.x, myPlayer.y - b.terminal.y);
                        return dist < b.terminal.radius;
                    }
                    return false;
                });

                if (ownedBuilding && network.isConnected()) {
                    network.send('terminalUpgrade', {
                        buildingId: ownedBuilding.id
                    });
                }
            }

            // Building/Door interaction with 'E' key
            if (key === 'e') {
                const currentAbility = abilitySystem.getCurrentAbility();
                const abilityActive = abilitySystem.isAbilityActive();

                if (!currentAbility || abilityActive) {
                    // First check for nearby building terminal
                    const nearbyBuilding = buildings.find(b => {
                        if (b.terminal && myPlayer) {
                            const dist = Math.hypot(myPlayer.x - b.terminal.x, myPlayer.y - b.terminal.y);
                            return dist < b.terminal.radius;
                        }
                        return false;
                    });

                    if (nearbyBuilding && network.isConnected()) {
                        if (nearbyBuilding.ownerId === playerId) {
                            network.send('terminalUpgrade', {
                                buildingId: nearbyBuilding.id
                            });
                        } else {
                            network.send('startHack', {
                                buildingId: nearbyBuilding.id
                            });
                        }
                        return;
                    }

                    // If no building nearby, check for nearby door
                    const nearbyDoor = obstacles.find(o =>
                        o.isDoor &&
                        Math.hypot(o.x + o.width/2 - myPlayer.x, o.y + o.height/2 - myPlayer.y) < 50
                    );

                    if (nearbyDoor && network.isConnected()) {
                        network.send('toggleDoor', {
                            doorId: nearbyDoor.id
                        });
                    }
                }
                // Ability activation is handled in AbilitySystem
            }
        });

        // Prevent right-click context menu
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Minimap state for mobile
        let minimapMinimized = false;
        let lastMinimapTap = 0;
        const doubleTapDelay = 300; // ms

        // Double-tap minimap to toggle size on mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!playerController.isMobile) return;

            const touch = e.touches[0];
            const touchX = touch.clientX;
            const touchY = touch.clientY;

            // Check if touch is on minimap area (top-right corner)
            const minimapSize = minimapMinimized ? 80 : 200;
            const minimapX = canvas.width - minimapSize - 10;
            const minimapY = minimapMinimized ? 10 : 20;

            if (touchX >= minimapX && touchX <= minimapX + minimapSize &&
                touchY >= minimapY && touchY <= minimapY + minimapSize) {

                const now = Date.now();
                if (now - lastMinimapTap < doubleTapDelay) {
                    minimapMinimized = !minimapMinimized;
                    lastMinimapTap = 0;
                } else {
                    lastMinimapTap = now;
                }
            }
        });

        // Mobile interact button
        const mobileInteractBtn = document.getElementById('mobileInteractBtn');
        const interactText = document.getElementById('interactText');
        let nearbyInteractable = null;

        mobileInteractBtn.addEventListener('click', () => {
            if (nearbyInteractable) {
                if (nearbyInteractable.type === 'door' && network.isConnected()) {
                    network.send('toggleDoor', {
                        doorId: nearbyInteractable.id
                    });
                } else if (nearbyInteractable.type === 'ability') {
                    abilitySystem.activateAbility();
                }
            }
        });

        // Click handler (delegates to WeaponSystem)
        window.addEventListener('click', (e) => {
            const mouse = playerController.getMousePosition();
            const newBullets = weaponSystem.handleClick(e, mouse, obstacles);
            if (newBullets) {
                bullets.push(...newBullets);
            }
        });

        // Game loop
        let lastUpdate = 0;
        const UPDATE_RATE = 100; // Send updates every 100ms (reduced for tunnel lag)

        // Network lag compensation
        let lastSentPickup = new Set();
        let lastSentBullet = new Set();

        function gameLoop() {
            // FPS calculation
            frameCount++;
            const now = Date.now();
            if (now - fpsUpdateTime > 1000) {
                fps = Math.round((frameCount * 1000) / (now - fpsUpdateTime));
                frameCount = 0;
                fpsUpdateTime = now;
            }

            // Interpolate other players' positions for smooth movement
            Object.values(players).forEach(player => {
                if (player.id !== playerId && player.targetX !== undefined) {
                    const distX = player.targetX - player.x;
                    const distY = player.targetY - player.y;
                    const distance = Math.sqrt(distX * distX + distY * distY);

                    let lerpFactor = 0.15;
                    if (distance > 50) lerpFactor = 0.25;

                    player.x += distX * lerpFactor;
                    player.y += distY * lerpFactor;

                    let angleDiff = player.targetAngle - player.angle;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    player.angle += angleDiff * lerpFactor;
                }
            });

            // Update player (uses PlayerController system)
            if (myPlayer && myPlayer.health > 0) {
                playerController.update(terrain, obstacles);

                // Check for nearby interactables on mobile
                if (playerController.isMobile) {
                    const nearbyDoor = obstacles.find(o =>
                        o.isDoor &&
                        Math.hypot(o.x + o.width/2 - myPlayer.x, o.y + o.height/2 - myPlayer.y) < 50
                    );

                    const currentAbility = abilitySystem.getCurrentAbility();
                    const abilityActive = abilitySystem.isAbilityActive();

                    if (nearbyDoor) {
                        nearbyInteractable = { type: 'door', id: nearbyDoor.id };
                        interactText.textContent = nearbyDoor.isOpen ? 'Close' : 'Open';
                        mobileInteractBtn.style.display = 'block';
                    } else if (currentAbility && !abilityActive) {
                        nearbyInteractable = { type: 'ability' };
                        interactText.textContent = 'Use';
                        mobileInteractBtn.style.display = 'block';
                    } else {
                        nearbyInteractable = null;
                        mobileInteractBtn.style.display = 'none';
                    }
                }

                // Auto-fire when aim joystick is active (uses WeaponSystem)
                if (playerController.isAimJoystickActive()) {
                    const newBullets = weaponSystem.autoFire();
                    if (newBullets) {
                        bullets.push(...newBullets);
                    }
                }

                // Check pickup collision
                pickups.forEach(pickup => {
                    const dx = myPlayer.x - pickup.x;
                    const dy = myPlayer.y - pickup.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < Constants.PLAYER_SIZE + 15) {
                        if (lastSentPickup.has(pickup.id)) return;

                        let canCollect = false;
                        if (pickup.type === 'health' && myPlayer.health < myPlayer.maxHealth) {
                            canCollect = true;
                        } else if (pickup.type === 'armor' && myPlayer.armor < myPlayer.maxArmor) {
                            canCollect = true;
                        } else if (pickup.type.startsWith('weapon_')) {
                            const weaponType = pickup.type.replace('weapon_', '');
                            const currentWeapon = weaponSystem.getCurrentWeapon();

                            if (currentWeapon !== weaponType) {
                                // Drop current weapon (except pistol)
                                if (currentWeapon !== 'pistol') {
                                    const dropData = {
                                        id: 'weapon_drop_' + Date.now(),
                                        type: 'weapon_' + currentWeapon,
                                        x: myPlayer.x,
                                        y: myPlayer.y
                                    };
                                    network.send('dropAbility', {
                                        pickup: dropData
                                    });
                                }
                                canCollect = true;
                            } else {
                                // Refill ammo for current weapon
                                weaponSystem.refillAmmo(weaponType);
                                canCollect = true;
                            }
                        } else if (pickup.type.startsWith('ability_')) {
                            const abilityType = pickup.type.replace('ability_', '');
                            canCollect = abilitySystem.pickupAbility(abilityType);
                        }

                        if (canCollect) {
                            network.send('collectPickup', { pickupId: pickup.id });
                            lastSentPickup.add(pickup.id);
                            setTimeout(() => lastSentPickup.delete(pickup.id), 500);
                        }
                    }
                });
            }

            // Update particles (uses ParticleSystem)
            particleSystem.update();

            // Update bullets (uses PhysicsSystem)
            bullets = physicsSystem.updateBullets(bullets, obstacles, players);

            // Update blade swirl ability (uses AbilitySystem)
            abilitySystem.update(obstacles, players);

            // Update camera (uses PlayerController)
            playerController.updateCamera();
            const camera = playerController.getCamera();

            // === RENDERING PHASE ===
            // All rendering is now handled by the Renderer class (Phase 2 refactoring)
            const toolSwingState = weaponSystem.getToolSwingState();
            renderer.render({
                terrain,
                floors,
                obstacles,
                buildings,
                pickups,
                particles: particleSystem.getParticles(),
                bullets,
                players,
                myPlayer,
                playerId,
                currentTool: weaponSystem.getCurrentTool(),
                currentWeapon: weaponSystem.getCurrentWeapon(),
                toolSwingTime: toolSwingState.time,
                toolSwingDuration: toolSwingState.duration,
                blades: abilitySystem.getBlades(),
                bladeAngle: abilitySystem.getBladeAngle(),
                abilityActive: abilitySystem.isAbilityActive(),
                currentAbility: abilitySystem.getCurrentAbility(),
                fps,
                ping,
                minimapMinimized,
                isMobile: playerController.isMobile
            });

            // Update UI
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
