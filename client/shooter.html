<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Shooter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e27;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: calc(100vh - 120px); /* Leave space for toolbar */
        }
        @media (max-width: 768px) and (orientation: portrait) {
            canvas {
                height: calc(100vh - 100px); /* Smaller toolbar in portrait */
            }
        }
        /* Bottom Toolbar */
        #toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: linear-gradient(to top, rgba(10, 14, 39, 0.95), rgba(10, 14, 39, 0.8));
            border-top: 3px solid rgba(0, 255, 136, 0.3);
            display: none; /* Hidden until game starts */
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }

        /* Player Info Section */
        .player-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }
        .player-name {
            color: #00ff88;
            font-size: 18px;
            font-weight: bold;
        }
        .health-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s;
        }
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .armor-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .armor-fill {
            height: 100%;
            background: linear-gradient(90deg, #4488ff, #66aaff);
            transition: width 0.3s;
        }
        .armor-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .stamina-bar {
            background: rgba(0, 0, 0, 0.5);
            height: 14px;
            border-radius: 7px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            margin-top: 5px;
        }
        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f 0%, #f39c12 100%);
            transition: width 0.1s ease-out;
        }
        .stamina-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Toolbelt Section */
        .toolbelt {
            display: flex;
            gap: 10px;
            margin: 0 auto;
        }
        .tool-slot {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .tool-slot:hover {
            border-color: rgba(0, 255, 136, 0.5);
            transform: translateY(-3px);
        }
        .tool-slot.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        .tool-icon {
            font-size: 28px;
        }
        .tool-key {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
        }
        .tool-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 2px;
        }

        /* Stats Section */
        .stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
            text-align: right;
        }
        .stat-item {
            color: white;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        .stat-icon {
            font-size: 18px;
        }
        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 12px;
            border: 2px solid #00ff88;
            color: white;
            text-align: center;
            min-width: 400px;
        }
        #menu h1 { color: #00ff88; margin-bottom: 20px; }
        #menu input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #1a1e3a;
            border: 2px solid #00ff88;
            color: white;
            border-radius: 6px;
            font-size: 16px;
        }
        #menu button {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #00ff88;
            border: none;
            color: #0a0e27;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
        #menu button:hover { background: #00dd77; }
        .color-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
        }
        .color-btn.selected { border-color: white; }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1001; /* Above toolbar */
        }
        .mobile-joystick {
            position: fixed;
            bottom: 130px; /* Just above the 120px toolbar */
            left: 15%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            pointer-events: auto;
        }
        /* Portrait mode - smaller controls */
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-joystick {
                bottom: 110px; /* Just above the 100px toolbar */
                left: 15%;
                width: 90px;
                height: 90px;
            }
        }
        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            position: absolute;
        }
        .joystick-stick {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.6);
            border: 3px solid rgba(0, 255, 136, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .joystick-stick {
                width: 40px;
                height: 40px;
            }
        }
        .mobile-aim-joystick {
            position: fixed;
            bottom: 130px; /* Just above the 120px toolbar */
            right: 15%;
            transform: translateX(50%);
            width: 100px;
            height: 100px;
            pointer-events: auto;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-aim-joystick {
                bottom: 110px; /* Just above the 100px toolbar */
                right: 15%;
                width: 90px;
                height: 90px;
            }
        }
        .mobile-interact-btn {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border: 3px solid #fff;
            color: white;
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            z-index: 1002;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        .mobile-interact-btn:active {
            background: linear-gradient(135deg, #00cc66, #00aa55);
            transform: translateX(-50%) scale(0.95);
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .mobile-interact-btn {
                bottom: 110px;
            }
        }
        @media (max-width: 768px), (pointer: coarse) {
            #controls { display: none !important; }
        }
        /* Compact toolbar for portrait mode */
        @media (max-width: 768px) and (orientation: portrait) {
            #toolbar {
                height: 100px;
                padding: 0 10px;
            }
            .player-info {
                min-width: 140px;
                gap: 4px;
            }
            .player-name {
                font-size: 14px;
            }
            .health-bar {
                height: 18px;
            }
            .armor-bar {
                height: 14px;
            }
            .stamina-bar {
                height: 10px;
            }
            .mobile-joystick {
                bottom: 110px;
            }
            .mobile-shoot-area {
                bottom: 100px;
                height: calc(100vh - 100px);
            }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="mobile-joystick" id="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
        <div class="mobile-aim-joystick" id="aimJoystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="aimJoystickStick"></div>
        </div>
        <button class="mobile-interact-btn" id="mobileInteractBtn" style="display: none;">
            <span id="interactText">E</span>
        </button>
    </div>

    <!-- Bottom Toolbar -->
    <div id="toolbar">
        <!-- Left: Player Info -->
        <div class="player-info">
            <div class="player-name" id="playerName">Player</div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%;"></div>
                <div class="health-text" id="healthText">100/100</div>
            </div>
            <div class="armor-bar">
                <div class="armor-fill" id="armorFill" style="width: 0%;"></div>
                <div class="armor-text" id="armorText">0/100</div>
            </div>
            <div class="stamina-bar">
                <div class="stamina-fill" id="staminaFill" style="width: 100%;"></div>
                <div class="stamina-text" id="staminaText">100</div>
            </div>
        </div>

        <!-- Center: Toolbelt -->
        <div class="toolbelt">
            <div class="tool-slot" id="slot1" onclick="selectTool(1)">
                <div class="tool-key">1</div>
                <div class="tool-icon">🔨</div>
                <div class="tool-label">Hammer</div>
            </div>
            <div class="tool-slot active" id="slot2" onclick="selectTool(2)">
                <div class="tool-key">2</div>
                <div class="tool-icon">🔫</div>
                <div class="tool-label" id="weaponLabel">Pistol</div>
            </div>
            <div class="tool-slot" id="slot3" onclick="selectTool(3)">
                <div class="tool-key">3</div>
                <div class="tool-icon">🔧</div>
                <div class="tool-label">Repair</div>
            </div>
        </div>

        <!-- Right: Stats -->
        <div class="stats">
            <div class="stat-item">
                <span>Scrap:</span>
                <span class="stat-icon">⚙️</span>
                <span class="stat-value" id="scrapCount">0</span>
            </div>
            <div class="stat-item">
                <span>Ammo:</span>
                <span class="stat-icon">📦</span>
                <span class="stat-value" id="ammoCount">∞</span>
            </div>
            <div class="stat-item">
                <span>Ability:</span>
                <span class="stat-value" id="abilityName">None</span>
            </div>
            <div class="stat-item" id="pcIcon" onclick="openTerminal()" style="cursor: pointer; display: none;" title="Building Terminal">
                <span class="stat-icon" style="font-size: 24px;">💻</span>
            </div>
        </div>
    </div>

    <!-- Old-school Terminal Popup -->
    <div id="terminalPopup" style="display: none;">
        <div id="terminalContent">
            <div id="terminalHeader">
                <span>BUILDING TERMINAL v1.0</span>
                <button onclick="closeTerminal()" style="float: right;">X</button>
            </div>
            <div id="terminalBody">
                <div id="terminalText"></div>
            </div>
            <div id="terminalButtons"></div>
        </div>
    </div>

    <div id="menu">
        <h1>🎯 MULTIPLAYER SHOOTER</h1>
        <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />

        <div style="margin: 15px 0; color: #00ff88; font-weight: bold;">Choose Color:</div>
        <div class="color-picker" id="colorPicker"></div>

        <div style="margin: 20px 0; color: #00ff88; font-weight: bold;">Select Server:</div>
        <div id="serverButtons" style="display: flex; flex-direction: column; gap: 10px;"></div>

        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #333;">
            <input type="text" id="customServerInput" placeholder="Or enter custom URL (wss://...)" />
            <button onclick="connectCustom()" style="margin-top: 10px;">Connect to Custom Server</button>
        </div>
    </div>

    <script type="module">
        // Import utility modules (Phase 1 refactoring)
        import * as Constants from './js/utils/constants.js';
        import * as MathUtils from './js/utils/math.js';
        import * as Helpers from './js/utils/helpers.js';

        // Import rendering modules (Phase 2 refactoring)
        import { Renderer } from './js/rendering/Renderer.js';

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Initialize main renderer (Phase 2 refactoring)
        const renderer = new Renderer(ctx, canvas);

        // Set canvas size (leave space for toolbar)
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            // Account for toolbar height
            const isPortrait = window.innerHeight > window.innerWidth && window.innerWidth <= 768;
            const toolbarHeight = isPortrait ? 100 : 120;
            canvas.height = window.innerHeight - toolbarHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Map size (100m = 5000px) - Using constants from module
        const Constants.MAP_WIDTH = Constants.Constants.MAP_WIDTH;
        const Constants.MAP_HEIGHT = Constants.Constants.MAP_HEIGHT;

        // Camera for following player
        let cameraX = 0;
        let cameraY = 0;

        // Game state
        let ws = null;
        let playerId = null;
        let players = {};
        let bullets = [];
        let particles = [];
        let pickups = [];
        let obstacles = [];
        let myPlayer = null;

        const keys = {};
        const mouse = { x: canvas.width / 2, y: canvas.height / 2 };

        const Constants.PLAYER_SIZE = Constants.Constants.PLAYER_SIZE;
        const MOVE_SPEED = Constants.MOVE_SPEED;

        // Tool swing animation
        let toolSwingTime = 0;
        let toolSwingDuration = 300; // ms

        // Terrain and block types
        let terrain = [];
        let floors = [];
        let buildings = []; // Building capture zones
        let currentSpeedModifier = 1.0;

        // Weapon types - Using constants from module
        const WEAPONS = Constants.WEAPONS;

        let currentWeapon = 'pistol';
        let weaponAmmo = {}; // Track ammo for each weapon
        let lastShot = 0;
        let currentTool = null; // 'hammer', 'repair', or null

        // Ability system
        let currentAbility = null; // 'bladeswirl', 'shield', 'grapple'
        let abilityActive = false;
        let blades = []; // Spinning blades around player
        let bladeAngle = 0;

        // Explosion helper function
        function createExplosion(x, y, radius, wallDamage, playerDamage) {
            // Damage all obstacles in radius
            obstacles.forEach(obs => {
                const centerX = obs.x + obs.width / 2;
                const centerY = obs.y + obs.height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < radius) {
                    const damageFalloff = 1 - (dist / radius);
                    const damage = Math.floor(wallDamage * damageFalloff);

                    send({
                        type: 'obstacleHit',
                        obstacleId: obs.id,
                        damage: damage
                    });
                }
            });

            // Damage all players in radius (including self!)
            Object.values(players).forEach(player => {
                const dx = x - player.x;
                const dy = y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < radius) {
                    const damageFalloff = 1 - (dist / radius);
                    const damage = Math.floor(playerDamage * damageFalloff);

                    send({
                        type: 'bulletHit',
                        bulletId: 'explosion_' + Date.now() + '_' + Math.random(),
                        targetId: player.id,
                        damage: damage
                    });
                }
            });

            // Create explosion particles
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 / 30) * i;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (8 + Math.random() * 8),
                    vy: Math.sin(angle) * (8 + Math.random() * 8),
                    size: 5 + Math.random() * 8,
                    life: 1.0,
                    color: i % 3 === 0 ? '#ff6600' : '#ffaa00'
                });
            }
        }

        // FPS tracking
        let fps = 60;
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let fpsUpdateTime = Date.now();

        // Ping tracking
        let ping = 0;
        let pingStart = 0;
        let pingUpdateInterval = null;

        // Config with localStorage persistence
        let persistentPlayerId = localStorage.getItem('shooterPlayerId');
        if (!persistentPlayerId) {
            persistentPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('shooterPlayerId', persistentPlayerId);
        }

        let playerName = localStorage.getItem('shooterPlayerName') || '';
        let playerColor = localStorage.getItem('shooterPlayerColor') || '#4ecdc4';

        const colors = ['#4ecdc4', '#ff6b6b', '#95e1d3', '#f38181', '#aa96da', '#fcbad3',
                       '#a8d8ea', '#ffffd2', '#ffd93d', '#6bcf7f', '#ff8c42', '#c779d0'];

        // Setup color picker
        const colorPicker = document.getElementById('colorPicker');
        colors.forEach(color => {
            const btn = document.createElement('div');
            btn.className = 'color-btn';
            btn.style.background = color;
            btn.onclick = () => {
                playerColor = color;
                localStorage.setItem('shooterPlayerColor', color);
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            };
            if (color === playerColor) btn.classList.add('selected');
            colorPicker.appendChild(btn);
        });

        // Pre-fill name input with saved name
        if (playerName) {
            document.getElementById('nameInput').value = playerName;
        }

        // Auto-detect server URL based on how page was accessed
        let autoServerUrl = null;
        const currentHost = window.location.host;
        const isLocalhost = currentHost.includes('localhost') || currentHost.includes('127.0.0.1');

        if (!isLocalhost) {
            // Accessed via public URL - auto-connect to same host's WebSocket
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            autoServerUrl = `${protocol}//${currentHost}`;
            console.log('Public access detected, will auto-connect to:', autoServerUrl);
        }

        // Available servers for manual selection (only shown for localhost)
        const availableServers = [
            { name: '🏠 Local Server', url: 'ws://localhost:3001', type: 'local' },
        ];

        // Load tunnel URL if available (for localhost users)
        let tunnelUrl = null;

        // Render immediately if public URL
        if (autoServerUrl) {
            renderServerButtons();
        } else {
            // Otherwise fetch tunnel URL for localhost users
            fetch('./server-url.json')
                .then(res => res.json())
                .then(data => {
                    tunnelUrl = data.url;
                    availableServers.push({ name: '🌐 Public Tunnel', url: tunnelUrl, type: 'tunnel' });
                    renderServerButtons();
                })
                .catch((err) => {
                    console.log('No tunnel URL found (this is OK if running locally)');
                    renderServerButtons();
                });
        }

        function renderServerButtons() {
            const container = document.getElementById('serverButtons');
            container.innerHTML = '';

            // If accessed via public URL, show single "Start Game" button
            if (autoServerUrl) {
                const btn = document.createElement('button');
                btn.textContent = '🎮 START GAME';
                btn.style.background = '#00ff88';
                btn.style.color = '#0a0e27';
                btn.style.fontSize = '20px';
                btn.style.padding = '15px 30px';
                btn.style.fontWeight = 'bold';
                btn.onclick = () => startGame(autoServerUrl);
                container.appendChild(btn);
                return;
            }

            // Otherwise show server selection for localhost users
            availableServers.forEach(server => {
                const btn = document.createElement('button');
                btn.textContent = server.name + ' - ' + server.url;
                btn.style.background = server.type === 'tunnel' ? '#00ff88' : '#1a2040';
                btn.style.color = server.type === 'tunnel' ? '#0a0e27' : 'white';
                btn.onclick = () => startGame(server.url);
                container.appendChild(btn);
            });
        }

        // Start game
        function startGame(serverUrl) {
            if (!serverUrl) {
                alert('Please select a server or enter a custom URL');
                return;
            }

            playerName = document.getElementById('nameInput').value.trim() || 'Player';
            localStorage.setItem('shooterPlayerName', playerName);

            document.getElementById('menu').style.display = 'none';
            document.getElementById('toolbar').style.display = 'flex';
            document.getElementById('playerName').textContent = playerName;

            // Show mobile controls if on mobile
            if (isMobile) {
                document.querySelector('.mobile-controls').style.display = 'block';
            }

            connectToServer(serverUrl);
        }

        // Tool selection function
        function selectTool(slot) {
            // Remove active class from all slots
            document.getElementById('slot1').classList.remove('active');
            document.getElementById('slot2').classList.remove('active');
            document.getElementById('slot3').classList.remove('active');

            // Add active class to selected slot
            document.getElementById('slot' + slot).classList.add('active');

            // Update current tool
            if (slot === 1) {
                currentTool = 'hammer';
                console.log('🔨 Hammer equipped');
            } else if (slot === 2) {
                currentTool = null;
                console.log('🔫 Weapon equipped');
            } else if (slot === 3) {
                currentTool = 'repair';
                console.log('🔧 Repair tool equipped');
            }
        }

        // Update UI function
        function updateUI() {
            if (!myPlayer) return;

            // Update health bar
            const healthPercent = (myPlayer.health / myPlayer.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = myPlayer.health + '/' + myPlayer.maxHealth;

            // Update armor bar
            const armorPercent = (myPlayer.armor / myPlayer.maxArmor) * 100;
            document.getElementById('armorFill').style.width = armorPercent + '%';
            document.getElementById('armorText').textContent = myPlayer.armor + '/' + myPlayer.maxArmor;

            // Update stamina bar
            const staminaPercent = (myPlayer.stamina / myPlayer.maxStamina) * 100;
            document.getElementById('staminaFill').style.width = staminaPercent + '%';
            document.getElementById('staminaText').textContent = Math.round(myPlayer.stamina);

            // Update scrap
            document.getElementById('scrapCount').textContent = myPlayer.scrap || 0;

            // Update ammo
            const currentAmmo = weaponAmmo[currentWeapon] ?? Constants.WEAPONS[currentWeapon]?.ammo;
            document.getElementById('ammoCount').textContent = currentAmmo === Infinity ? '∞' : currentAmmo;

            // Update weapon label
            if (currentWeapon && Constants.WEAPONS[currentWeapon]) {
                document.getElementById('weaponLabel').textContent = Constants.WEAPONS[currentWeapon].name;
            }
        }

        function connectCustom() {
            const url = document.getElementById('customServerInput').value.trim();

            if (!url) {
                alert('Please enter a server URL');
                return;
            }

            if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                alert('Server URL must start with ws:// or wss://');
                return;
            }

            startGame(url);
        }

        function connectToServer(url) {
            ws = new WebSocket(url);

            ws.onopen = () => {
                console.log('✅ Connected to server!');

                // Send persistent player ID immediately
                send({
                    type: 'register',
                    persistentId: persistentPlayerId,
                    name: playerName,
                    color: playerColor
                });

                // Start ping measurement
                pingUpdateInterval = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        pingStart = Date.now();
                        send({ type: 'ping' });
                    }
                }, 1000); // Measure ping every second
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                switch(data.type) {
                    case 'init':
                        playerId = data.playerId;
                        console.log('🎮 Player initialized:', playerId);

                        // Use server position
                        const serverPlayer = data.players.find(p => p.id === data.playerId);
                        console.log('📍 Spawn position:', serverPlayer ? `(${Math.round(serverPlayer.x)}, ${Math.round(serverPlayer.y)})` : 'default');

                        myPlayer = {
                            id: data.playerId,
                            name: playerName,
                            x: serverPlayer ? serverPlayer.x : canvas.width / 2,
                            y: serverPlayer ? serverPlayer.y : canvas.height / 2,
                            angle: 0,
                            health: 100,
                            maxHealth: 100,
                            armor: 0,
                            maxArmor: 100,
                            color: playerColor,
                            weapon: 'pistol',
                            scrap: 0,
                            stamina: 100,
                            maxStamina: 100,
                            invulnerable: true,
                            invulnerableUntil: Date.now() + 1500
                        };
                        players[playerId] = myPlayer;

                        // Add other players
                        data.players.forEach(p => {
                            if (p.id !== playerId) {
                                players[p.id] = p;
                            }
                        });

                        console.log('👥 Total players:', Object.keys(players).length);

                        // Send name update
                        send({ type: 'updateName', name: playerName });

                        document.getElementById('playerName').textContent = playerName;
                        break;

                    case 'playerJoined':
                        players[data.player.id] = data.player;
                        updatePlayerCount();
                        break;

                    case 'playerLeft':
                        delete players[data.playerId];
                        updatePlayerCount();
                        break;

                    case 'playerMoved':
                        if (players[data.playerId] && data.playerId !== playerId) {
                            const player = players[data.playerId];

                            // Store target position for interpolation
                            player.targetX = data.x;
                            player.targetY = data.y;
                            player.targetAngle = data.angle;

                            // Initialize if first update
                            if (player.x === undefined) {
                                player.x = data.x;
                                player.y = data.y;
                            }
                        }
                        break;

                    case 'playerShot':
                        // Don't add bullets we already created locally
                        if (data.playerId === playerId) {
                            break; // Skip our own bullets echoed from server
                        }

                        bullets.push({
                            id: data.bulletId,
                            x: data.x,
                            y: data.y,
                            vx: data.vx,
                            vy: data.vy,
                            playerId: data.playerId,
                            damage: data.damage || 20,
                            size: data.size || 5,
                            color: data.color || '#ffeb3b',
                            explosive: data.explosive || false,
                            explosionRadius: data.explosionRadius,
                            penetration: data.penetration
                        });
                        break;

                    case 'playerNameChanged':
                        if (players[data.playerId]) {
                            players[data.playerId].name = data.name;
                        }
                        break;

                    case 'playerDamaged':
                        if (players[data.playerId]) {
                            players[data.playerId].health = data.health;
                            if (data.playerId === playerId && myPlayer) {
                                myPlayer.health = data.health;
                            }
                        }
                        break;

                    case 'playerDied':
                        console.log('Player died:', data.playerId);
                        // Create explosion at player location
                        if (players[data.playerId]) {
                            const player = players[data.playerId];
                            const particleCount = 12;
                            for (let i = 0; i < particleCount; i++) {
                                const angle = (Math.PI * 2 / particleCount) * i;
                                const speed = 3 + Math.random() * 3;
                                particles.push({
                                    x: player.x,
                                    y: player.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    color: player.color || '#4ecdc4',
                                    life: 1.0,
                                    size: 8 + Math.random() * 4
                                });
                            }
                        }
                        break;

                    case 'playerRespawned':
                        if (players[data.playerId]) {
                            players[data.playerId].x = data.x;
                            players[data.playerId].y = data.y;
                            players[data.playerId].health = data.health;
                            players[data.playerId].invulnerable = true;
                            players[data.playerId].invulnerableUntil = Date.now() + 1500;

                            if (data.playerId === playerId) {
                                myPlayer.x = data.x;
                                myPlayer.y = data.y;
                                myPlayer.health = data.health;
                                myPlayer.invulnerable = true;
                                myPlayer.invulnerableUntil = Date.now() + 1500;
                                currentWeapon = 'pistol';
                            }
                        }
                        break;

                    case 'pickupsUpdate':
                        pickups = data.pickups;
                        console.log('📦 Received', pickups.length, 'pickups');
                        break;

                    case 'obstaclesUpdate':
                        obstacles = data.obstacles;
                        console.log(`Received ${obstacles.length} obstacles from server`);
                        break;
                    case 'doorToggled':
                        // Handle multiple door blocks (3-block wide doors)
                        const doorIds = data.doorIds || [data.doorId]; // Support both old and new format
                        doorIds.forEach(doorId => {
                            const door = obstacles.find(o => o.id === doorId);
                            if (door) {
                                door.isOpen = data.isOpen;
                            }
                        });
                        console.log(`${doorIds.length} door block(s) toggled: ${data.isOpen ? 'open' : 'closed'}`);
                        break;

                    case 'terrainUpdate':
                        terrain = data.terrain;
                        console.log(`Received ${terrain.length} terrain tiles from server`);
                        break;

                    case 'floorsUpdate':
                        floors = data.floors;
                        console.log(`Received ${floors.length} floor tiles from server`);
                        break;

                    case 'buildingsUpdate':
                        buildings = data.buildings;
                        console.log(`Received ${buildings.length} buildings from server`);
                        break;

                    case 'buildingCaptured':
                        const capturedBuilding = buildings.find(b => b.id === data.buildingId);
                        if (capturedBuilding) {
                            capturedBuilding.ownerId = data.ownerId;
                            capturedBuilding.ownerName = data.ownerName;
                            console.log(`${data.ownerName} captured ${data.buildingId}!`);
                        }
                        break;

                    case 'buildingNeutralized':
                        const neutralBuilding = buildings.find(b => b.id === data.buildingId);
                        if (neutralBuilding) {
                            neutralBuilding.ownerId = null;
                            neutralBuilding.ownerName = null;
                        }
                        break;

                    case 'buildingLost':
                        const lostBuilding = buildings.find(b => b.id === data.buildingId);
                        if (lostBuilding) {
                            lostBuilding.ownerId = null;
                            lostBuilding.ownerName = null;
                        }
                        break;

                    case 'buildingCaptureProgress':
                        const progressBuilding = buildings.find(b => b.id === data.buildingId);
                        if (progressBuilding) {
                            if (!progressBuilding.captureProgress) progressBuilding.captureProgress = {};
                            progressBuilding.captureProgress[data.playerId] = data.progress;
                            progressBuilding.ownerId = data.ownerId;
                        }
                        break;

                    case 'obstacleDestroyed':
                        // Convert obstacle to debris instead of removing it
                        const destroyedObs = obstacles.find(o => o.id === data.obstacleId);
                        if (destroyedObs && data.isDebris) {
                            // Convert to debris (walkable rubble)
                            destroyedObs.isDestroyed = true;
                            destroyedObs.isWall = false;
                            destroyedObs.health = 0;
                            destroyedObs.originalType = destroyedObs.blockType; // Store original type
                            destroyedObs.blockType = 'debris';
                        } else if (destroyedObs) {
                            // Legacy: remove if not debris
                            obstacles = obstacles.filter(o => o.id !== data.obstacleId);
                        }

                        // Create small voxel debris particles
                        const centerX = data.x + data.width / 2;
                        const centerY = data.y + data.height / 2;

                        for (let i = 0; i < 8; i++) {
                            particles.push({
                                x: centerX,
                                y: centerY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                size: 4 + Math.random() * 4,
                                life: 1.0,
                                color: '#00ffff',
                                isVoxel: true
                            });
                        }
                        break;

                    case 'obstacleDamaged':
                        // Update obstacle health
                        const damagedObs = obstacles.find(o => o.id === data.obstacleId);
                        if (damagedObs) {
                            damagedObs.health = data.health;
                        }
                        break;

                    case 'pong':
                        if (pingStart > 0) {
                            ping = Date.now() - pingStart;
                            pingStart = 0;
                        }
                        break;

                    case 'pickupCollected':
                        // Remove pickup
                        pickups = pickups.filter(p => p.id !== data.pickupId);

                        if (data.playerId === playerId) {
                            if (data.pickupType === 'health') {
                                myPlayer.health = Math.min(myPlayer.maxHealth, myPlayer.health + 30);
                            } else if (data.pickupType === 'armor') {
                                myPlayer.armor = Math.min(myPlayer.maxArmor, myPlayer.armor + 50);
                            } else if (data.pickupType.startsWith('weapon_')) {
                                const weaponType = data.pickupType.replace('weapon_', '');
                                currentWeapon = weaponType;
                                myPlayer.weapon = weaponType;
                                // Initialize ammo if first time picking up
                                if (weaponAmmo[weaponType] === undefined) {
                                    weaponAmmo[weaponType] = Constants.WEAPONS[weaponType].ammo;
                                }
                            }
                        }
                        break;

                    case 'playerArmorUpdate':
                        if (players[data.playerId]) {
                            players[data.playerId].armor = data.armor;
                            if (data.playerId === playerId && myPlayer) {
                                myPlayer.armor = data.armor;
                            }
                        }
                        break;

                    case 'playerScrapUpdate':
                        if (players[data.playerId]) {
                            players[data.playerId].scrap = data.scrap;
                            if (data.playerId === playerId && myPlayer) {
                                myPlayer.scrap = data.scrap;
                            }
                        }
                        break;
                }
            };

            ws.onclose = () => {
                console.log('Disconnected');
            };
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            }
        }

        function updatePlayerCount() {
            document.getElementById('playerCount').textContent = Object.keys(players).length;
        }

        // Input handlers
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;

            // Tool selection
            if (key === '1') {
                selectTool(1);
            } else if (key === '2') {
                selectTool(2);
            } else if (key === '3') {
                selectTool(3);
            }

            // Terminal interaction with 'T' key
            if (key === 't') {
                // Check if near any owned building's terminal
                const ownedBuilding = buildings.find(b => {
                    if (b.ownerId === playerId && b.terminal && myPlayer) {
                        const dist = Math.hypot(myPlayer.x - b.terminal.x, myPlayer.y - b.terminal.y);
                        return dist < b.terminal.radius;
                    }
                    return false;
                });

                if (ownedBuilding && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'terminalUpgrade',
                        buildingId: ownedBuilding.id
                    }));
                }
            }

            // Building/Door interaction with 'E' key
            if (key === 'e') {
                if (!currentAbility || abilityActive) {
                    // First check for nearby building terminal
                    const nearbyBuilding = buildings.find(b => {
                        if (b.terminal && myPlayer) {
                            const dist = Math.hypot(myPlayer.x - b.terminal.x, myPlayer.y - b.terminal.y);
                            return dist < b.terminal.radius;
                        }
                        return false;
                    });

                    if (nearbyBuilding && ws && ws.readyState === WebSocket.OPEN) {
                        // Start hacking if not owned, or open management if owned
                        if (nearbyBuilding.ownerId === playerId) {
                            // Open management menu (for now, just upgrade)
                            ws.send(JSON.stringify({
                                type: 'terminalUpgrade',
                                buildingId: nearbyBuilding.id
                            }));
                        } else {
                            // Start hack attempt
                            ws.send(JSON.stringify({
                                type: 'startHack',
                                buildingId: nearbyBuilding.id
                            }));
                        }
                        return;
                    }

                    // If no building nearby, check for nearby door
                    const nearbyDoor = obstacles.find(o =>
                        o.isDoor &&
                        Math.hypot(o.x + o.width/2 - myPlayer.x, o.y + o.height/2 - myPlayer.y) < 50
                    );

                    if (nearbyDoor && ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'toggleDoor',
                            doorId: nearbyDoor.id
                        }));
                    }
                } else if (currentAbility && !abilityActive) {
                    // Activate ability
                    activateAbility();
                }
            } else if (key === 'q' && currentAbility) {
                // Drop ability as pickup
                dropAbility();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX + cameraX;
            mouse.y = e.clientY + cameraY;
        });

        // Prevent right-click context menu
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Mobile touch controls
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickDeltaX = 0;
        let joystickDeltaY = 0;
        let joystickTouchId = null;
        let aimJoystickActive = false;
        let aimJoystickStartX = 0;
        let aimJoystickStartY = 0;
        let aimJoystickDeltaX = 0;
        let aimJoystickDeltaY = 0;
        let aimJoystickTouchId = null;
        let mobileAimX = 0;
        let mobileAimY = 0;
        let isMobile = false;

        // Minimap state for mobile
        let minimapMinimized = false;
        let lastMinimapTap = 0;
        const doubleTapDelay = 300; // ms

        const joystickEl = document.getElementById('joystick');
        const joystickStick = document.getElementById('joystickStick');
        const aimJoystickEl = document.getElementById('aimJoystick');
        const aimJoystickStick = document.getElementById('aimJoystickStick');

        // Detect if device is mobile
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            isMobile = true;
        }

        // Joystick touch handling
        joystickEl.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = joystickEl.getBoundingClientRect();
            joystickActive = true;
            joystickTouchId = touch.identifier;
            joystickStartX = rect.left + rect.width / 2;
            joystickStartY = rect.top + rect.height / 2;
        });

        window.addEventListener('touchmove', (e) => {
            // Handle movement joystick
            if (joystickActive && joystickTouchId !== null) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === joystickTouchId) {
                        const touch = e.touches[i];
                        const deltaX = touch.clientX - joystickStartX;
                        const deltaY = touch.clientY - joystickStartY;

                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 35;

                        if (distance > maxDistance) {
                            joystickDeltaX = (deltaX / distance) * maxDistance;
                            joystickDeltaY = (deltaY / distance) * maxDistance;
                        } else {
                            joystickDeltaX = deltaX;
                            joystickDeltaY = deltaY;
                        }

                        joystickStick.style.transform = `translate(calc(-50% + ${joystickDeltaX}px), calc(-50% + ${joystickDeltaY}px))`;
                        break;
                    }
                }
            }

            // Handle aim joystick
            if (aimJoystickActive && aimJoystickTouchId !== null) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === aimJoystickTouchId) {
                        const touch = e.touches[i];
                        const deltaX = touch.clientX - aimJoystickStartX;
                        const deltaY = touch.clientY - aimJoystickStartY;

                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 35;

                        if (distance > maxDistance) {
                            aimJoystickDeltaX = (deltaX / distance) * maxDistance;
                            aimJoystickDeltaY = (deltaY / distance) * maxDistance;
                        } else {
                            aimJoystickDeltaX = deltaX;
                            aimJoystickDeltaY = deltaY;
                        }

                        aimJoystickStick.style.transform = `translate(calc(-50% + ${aimJoystickDeltaX}px), calc(-50% + ${aimJoystickDeltaY}px))`;
                        break;
                    }
                }
            }
        });

        window.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];

                if (touch.identifier === joystickTouchId) {
                    joystickActive = false;
                    joystickTouchId = null;
                    joystickDeltaX = 0;
                    joystickDeltaY = 0;
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                }

                if (touch.identifier === aimJoystickTouchId) {
                    aimJoystickActive = false;
                    aimJoystickTouchId = null;
                    aimJoystickDeltaX = 0;
                    aimJoystickDeltaY = 0;
                    aimJoystickStick.style.transform = 'translate(-50%, -50%)';
                }
            }
        });

        // Aim joystick touch handling
        aimJoystickEl.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = aimJoystickEl.getBoundingClientRect();
            aimJoystickActive = true;
            aimJoystickTouchId = touch.identifier;
            aimJoystickStartX = rect.left + rect.width / 2;
            aimJoystickStartY = rect.top + rect.height / 2;
        });

        // Double-tap minimap to toggle size on mobile
        canvas.addEventListener('touchstart', (e) => {
            if (!isMobile) return;

            const touch = e.touches[0];
            const touchX = touch.clientX;
            const touchY = touch.clientY;

            // Check if touch is on minimap area (top-right corner)
            const minimapSize = minimapMinimized ? 80 : 200;
            const minimapX = canvas.width - minimapSize - 10;
            const minimapY = minimapMinimized ? 10 : 20;

            if (touchX >= minimapX && touchX <= minimapX + minimapSize &&
                touchY >= minimapY && touchY <= minimapY + minimapSize) {

                const now = Date.now();
                if (now - lastMinimapTap < doubleTapDelay) {
                    // Double tap detected - toggle minimap size
                    minimapMinimized = !minimapMinimized;
                    lastMinimapTap = 0; // Reset to prevent triple tap
                } else {
                    lastMinimapTap = now;
                }
            }
        });

        // Mobile interact button
        const mobileInteractBtn = document.getElementById('mobileInteractBtn');
        const interactText = document.getElementById('interactText');
        let nearbyInteractable = null;

        mobileInteractBtn.addEventListener('click', () => {
            if (nearbyInteractable) {
                if (nearbyInteractable.type === 'door' && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'toggleDoor',
                        doorId: nearbyInteractable.id
                    }));
                } else if (nearbyInteractable.type === 'ability' && currentAbility && !abilityActive) {
                    activateAbility();
                }
            }
        });

        // Ability functions
        function activateAbility() {
            if (currentAbility === 'bladeswirl') {
                abilityActive = true;
                // Create 4 spinning blades
                blades = [];
                for (let i = 0; i < 4; i++) {
                    blades.push({
                        angle: (Math.PI * 2 / 4) * i,
                        radius: 60
                    });
                }
                document.getElementById('abilityName').textContent = 'Blade Swirl (ACTIVE)';
                document.getElementById('abilityName').style.color = '#ff00ff';

                // Deactivate after 10 seconds
                setTimeout(() => {
                    abilityActive = false;
                    blades = [];
                    currentAbility = null;
                    document.getElementById('abilityName').textContent = 'None';
                    document.getElementById('abilityName').style.color = '#00ffff';
                }, 10000);
            }
        }

        function dropAbility() {
            // Create pickup where player drops it
            if (myPlayer && currentAbility) {
                const dropData = {
                    id: 'pickup_dropped_' + Date.now(),
                    type: 'ability_' + currentAbility,
                    x: myPlayer.x,
                    y: myPlayer.y
                };

                // Send to server so it persists for all players
                send({
                    type: 'dropAbility',
                    pickup: dropData
                });

                currentAbility = null;
                abilityActive = false;
                blades = [];
                document.getElementById('abilityName').textContent = 'None';
                document.getElementById('abilityName').style.color = '#00ffff';
            }
        }

        window.addEventListener('click', () => {
            if (!myPlayer || myPlayer.health <= 0) return;

            const now = Date.now();

            // Hammer tool - destroy blocks
            if (currentTool === 'hammer') {
                // Trigger swing animation
                toolSwingTime = Date.now();

                // Find closest block within hammer range (50px)
                let closestObs = null;
                let closestDist = 50;

                obstacles.forEach(obs => {
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;
                    const dx = mouse.x - centerX;
                    const dy = mouse.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < closestDist) {
                        closestObs = obs;
                        closestDist = dist;
                    }
                });

                if (closestObs) {
                    send({
                        type: 'hammerHit',
                        obstacleId: closestObs.id,
                        damage: 30
                    });
                }
                return;
            }

            // Repair tool - restore block health (close-range from player)
            if (currentTool === 'repair') {
                // Trigger swing animation
                toolSwingTime = Date.now();

                // Find closest damaged/debris block within repair range from PLAYER (60px range)
                let closestObs = null;
                let closestDist = 60;

                obstacles.forEach(obs => {
                    // Can repair damaged blocks OR debris blocks
                    if (obs.health < obs.maxHealth || obs.blockType === 'debris') {
                        const centerX = obs.x + obs.width / 2;
                        const centerY = obs.y + obs.height / 2;
                        const dx = myPlayer.x - centerX;
                        const dy = myPlayer.y - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < closestDist) {
                            closestObs = obs;
                            closestDist = dist;
                        }
                    }
                });

                if (closestObs && myPlayer.scrap >= 1) {
                    send({
                        type: 'repairBlock',
                        obstacleId: closestObs.id,
                        repairAmount: 20
                    });
                } else if (closestObs && myPlayer.scrap < 1) {
                    console.log('❌ Need 1 scrap to repair');
                }
                return;
            }

            const weapon = Constants.WEAPONS[currentWeapon];

            // Check fire rate
            if (now - lastShot < weapon.fireRate) return;

            // Check ammo
            const currentAmmo = weaponAmmo[currentWeapon] ?? weapon.ammo;
            if (currentAmmo <= 0) {
                // Out of ammo, switch to pistol
                currentWeapon = 'pistol';
                return;
            }

            lastShot = now;

            // Calculate angle to mouse first
            const dx = mouse.x - myPlayer.x;
            const dy = mouse.y - myPlayer.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                const baseAngle = Math.atan2(dy, dx);
                const pellets = weapon.pellets || 1;

                // Spawn bullets from gun tip (30px from center)
                const gunTipX = myPlayer.x + Math.cos(baseAngle) * 25;
                const gunTipY = myPlayer.y + Math.sin(baseAngle) * 25;

                for (let i = 0; i < pellets; i++) {
                    const spread = weapon.spread * (Math.random() - 0.5) * 2;
                    const angle = baseAngle + spread;

                    const bulletId = 'b_' + playerId + '_' + Date.now() + '_' + Math.random();
                    const vx = Math.cos(angle) * weapon.bulletSpeed;
                    const vy = Math.sin(angle) * weapon.bulletSpeed;

                    bullets.push({
                        id: bulletId,
                        x: gunTipX,
                        y: gunTipY,
                        vx,
                        vy,
                        playerId: playerId,
                        damage: weapon.damage,
                        size: weapon.bulletSize,
                        color: weapon.color,
                        explosive: weapon.explosive || false,
                        explosionRadius: weapon.explosionRadius,
                        penetration: weapon.penetration
                    });

                    send({
                        type: 'shoot',
                        bulletId,
                        x: gunTipX,
                        y: gunTipY,
                        vx,
                        vy,
                        damage: weapon.damage,
                        size: weapon.bulletSize,
                        color: weapon.color,
                        explosive: weapon.explosive || false,
                        explosionRadius: weapon.explosionRadius,
                        penetration: weapon.penetration
                    });
                }

                // Decrease ammo
                if (weapon.ammo !== Infinity) {
                    if (weaponAmmo[currentWeapon] === undefined) {
                        weaponAmmo[currentWeapon] = weapon.ammo;
                    }
                    weaponAmmo[currentWeapon]--;
                }
            }
        });

        // Game loop
        let lastUpdate = 0;
        const UPDATE_RATE = 100; // Send updates every 100ms (reduced for tunnel lag)

        // Network lag compensation
        let lastSentPickup = new Set();
        let lastSentBullet = new Set();

        function gameLoop() {
            // FPS calculation
            frameCount++;
            const now = Date.now();
            if (now - fpsUpdateTime > 1000) {
                fps = Math.round((frameCount * 1000) / (now - fpsUpdateTime));
                frameCount = 0;
                fpsUpdateTime = now;
            }

            // Update UI is now handled by updateUI() function called separately

            // Update camera to follow player
            if (myPlayer) {
                cameraX = myPlayer.x - canvas.width / 2;
                cameraY = myPlayer.y - canvas.height / 2;

                // Clamp camera to map bounds
                cameraX = Math.max(0, Math.min(Constants.Constants.MAP_WIDTH - canvas.width, cameraX));
                cameraY = Math.max(0, Math.min(Constants.Constants.MAP_HEIGHT - canvas.height, cameraY));
            }

            // Clear canvas
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save context and translate for camera
            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            // Draw grid (only visible area, less dense)
            ctx.strokeStyle = '#1a2040';
            ctx.lineWidth = 1;
            const gridStartX = Math.floor(cameraX / 100) * 100;
            const gridStartY = Math.floor(cameraY / 100) * 100;
            for (let x = gridStartX; x < cameraX + canvas.width + 100; x += 100) {
                ctx.beginPath();
                ctx.moveTo(x, Math.max(0, cameraY));
                ctx.lineTo(x, Math.min(Constants.Constants.MAP_HEIGHT, cameraY + canvas.height));
                ctx.stroke();
            }
            for (let y = gridStartY; y < cameraY + canvas.height + 100; y += 100) {
                ctx.beginPath();
                ctx.moveTo(Math.max(0, cameraX), y);
                ctx.lineTo(Math.min(Constants.Constants.MAP_WIDTH, cameraX + canvas.width), y);
                ctx.stroke();
            }

            // Draw map bounds (only if visible)
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, Constants.Constants.MAP_WIDTH, Constants.Constants.MAP_HEIGHT);

            // Interpolate other players' positions for smooth movement
            Object.values(players).forEach(player => {
                if (player.id !== playerId && player.targetX !== undefined) {
                    // Calculate distance to target
                    const distX = player.targetX - player.x;
                    const distY = player.targetY - player.y;
                    const distance = Math.sqrt(distX * distX + distY * distY);

                    // Use slower interpolation, but speed up if too far behind
                    let lerpFactor = 0.15; // Slower default
                    if (distance > 50) lerpFactor = 0.25; // Speed up if desynced

                    player.x += distX * lerpFactor;
                    player.y += distY * lerpFactor;

                    // Interpolate angle (handle wrapping)
                    let angleDiff = player.targetAngle - player.angle;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    player.angle += angleDiff * lerpFactor;
                }
            });

            // Update player
            if (myPlayer && myPlayer.health > 0) {
                // Get speed modifier from current terrain
                currentSpeedModifier = 1.0; // default
                for (const tile of terrain) {
                    if (myPlayer.x >= tile.x && myPlayer.x < tile.x + tile.size &&
                        myPlayer.y >= tile.y && myPlayer.y < tile.y + tile.size) {
                        currentSpeedModifier = tile.speedModifier;
                        break;
                    }
                }

                let dx = 0, dy = 0;

                // Check if sprinting
                const isSprinting = keys['shift'] && myPlayer.stamina > 0;
                const sprintMultiplier = isSprinting ? 1.8 : 1.0;

                // Stamina drain/regen
                const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright'] || (isMobile && joystickActive);
                if (isSprinting && isMoving) {
                    myPlayer.stamina = Math.max(0, myPlayer.stamina - 0.5); // Drain 0.5 per frame when sprinting
                } else {
                    myPlayer.stamina = Math.min(myPlayer.maxStamina, myPlayer.stamina + 0.2); // Regen 0.2 per frame
                }

                // Keyboard controls
                if (keys['w'] || keys['arrowup']) dy -= MOVE_SPEED * currentSpeedModifier * sprintMultiplier;
                if (keys['s'] || keys['arrowdown']) dy += MOVE_SPEED * currentSpeedModifier * sprintMultiplier;
                if (keys['a'] || keys['arrowleft']) dx -= MOVE_SPEED * currentSpeedModifier * sprintMultiplier;
                if (keys['d'] || keys['arrowright']) dx += MOVE_SPEED * currentSpeedModifier * sprintMultiplier;

                // Mobile joystick controls
                if (isMobile && joystickActive) {
                    dx = (joystickDeltaX / 35) * MOVE_SPEED * currentSpeedModifier * sprintMultiplier;
                    dy = (joystickDeltaY / 35) * MOVE_SPEED * currentSpeedModifier * sprintMultiplier;
                }

                // Normalize diagonal movement
                if (dx !== 0 && dy !== 0) {
                    const factor = 1 / Math.sqrt(2);
                    dx *= factor;
                    dy *= factor;
                }

                let newX = myPlayer.x + dx;
                let newY = myPlayer.y + dy;

                // Clamp to map bounds
                newX = Math.max(Constants.PLAYER_SIZE, Math.min(Constants.MAP_WIDTH - Constants.PLAYER_SIZE, newX));
                newY = Math.max(Constants.PLAYER_SIZE, Math.min(Constants.MAP_HEIGHT - Constants.PLAYER_SIZE, newY));

                // Check obstacle collision with sliding
                const checkCollision = (x, y) => {
                    for (const obs of obstacles) {
                        // Skip collision with open doors and debris
                        if ((obs.isDoor && obs.isOpen) || obs.isWall === false || obs.blockType === 'debris') {
                            continue;
                        }

                        const closestX = Math.max(obs.x, Math.min(x, obs.x + obs.width));
                        const closestY = Math.max(obs.y, Math.min(y, obs.y + obs.height));
                        const distX = x - closestX;
                        const distY = y - closestY;
                        if (distX * distX + distY * distY < Constants.PLAYER_SIZE * Constants.PLAYER_SIZE) {
                            return true;
                        }
                    }
                    return false;
                };

                // Try full movement
                if (!checkCollision(newX, newY)) {
                    myPlayer.x = newX;
                    myPlayer.y = newY;
                } else {
                    // Try sliding on X axis
                    if (!checkCollision(newX, myPlayer.y)) {
                        myPlayer.x = newX;
                    }
                    // Try sliding on Y axis
                    if (!checkCollision(myPlayer.x, newY)) {
                        myPlayer.y = newY;
                    }
                }

                // Check for nearby interactables on mobile
                if (isMobile) {
                    // Check for nearby door
                    const nearbyDoor = obstacles.find(o =>
                        o.isDoor &&
                        Math.hypot(o.x + o.width/2 - myPlayer.x, o.y + o.height/2 - myPlayer.y) < 50
                    );

                    if (nearbyDoor) {
                        nearbyInteractable = { type: 'door', id: nearbyDoor.id };
                        interactText.textContent = nearbyDoor.isOpen ? 'Close' : 'Open';
                        mobileInteractBtn.style.display = 'block';
                    } else if (currentAbility && !abilityActive) {
                        nearbyInteractable = { type: 'ability' };
                        interactText.textContent = 'Use';
                        mobileInteractBtn.style.display = 'block';
                    } else {
                        nearbyInteractable = null;
                        mobileInteractBtn.style.display = 'none';
                    }
                }

                // Update angle
                let aimX = mouse.x;
                let aimY = mouse.y;

                // Use aim joystick if active on mobile
                if (isMobile && aimJoystickActive && (aimJoystickDeltaX !== 0 || aimJoystickDeltaY !== 0)) {
                    // Aim joystick controls direction directly
                    myPlayer.angle = Math.atan2(aimJoystickDeltaY, aimJoystickDeltaX);
                } else if (isMobile && mobileAimX !== 0 && mobileAimY !== 0) {
                    // Fallback to tap-to-aim
                    aimX = mobileAimX;
                    aimY = mobileAimY;
                    const angleDx = aimX - myPlayer.x;
                    const angleDy = aimY - myPlayer.y;
                    myPlayer.angle = Math.atan2(angleDy, angleDx);
                } else {
                    // Desktop: aim at mouse
                    const angleDx = aimX - myPlayer.x;
                    const angleDy = aimY - myPlayer.y;
                    myPlayer.angle = Math.atan2(angleDy, angleDx);
                }

                // Auto-fire when aim joystick is active
                if (isMobile && aimJoystickActive && (aimJoystickDeltaX !== 0 || aimJoystickDeltaY !== 0)) {
                    const now = Date.now();
                    const weapon = WEAPONS[currentWeapon];

                    // Check fire rate
                    if (now - lastShot >= weapon.fireRate) {
                        // Check ammo
                        const currentAmmo = weaponAmmo[currentWeapon] ?? weapon.ammo;
                        if (currentAmmo > 0) {
                            lastShot = now;

                            // Shoot in the direction of aim joystick
                            const baseAngle = myPlayer.angle;
                            const pellets = weapon.pellets || 1;
                            const gunTipX = myPlayer.x + Math.cos(baseAngle) * 25;
                            const gunTipY = myPlayer.y + Math.sin(baseAngle) * 25;

                            for (let i = 0; i < pellets; i++) {
                                const spread = weapon.spread * (Math.random() - 0.5) * 2;
                                const angle = baseAngle + spread;

                                const bulletId = 'b_' + playerId + '_' + Date.now() + '_' + Math.random();
                                const vx = Math.cos(angle) * weapon.bulletSpeed;
                                const vy = Math.sin(angle) * weapon.bulletSpeed;

                                bullets.push({
                                    id: bulletId,
                                    x: gunTipX,
                                    y: gunTipY,
                                    vx,
                                    vy,
                                    playerId: playerId,
                                    damage: weapon.damage,
                                    size: weapon.bulletSize,
                                    color: weapon.color,
                                    explosive: weapon.explosive || false,
                                    explosionRadius: weapon.explosionRadius,
                                    penetration: weapon.penetration
                                });

                                send({
                                    type: 'shoot',
                                    bulletId,
                                    x: gunTipX,
                                    y: gunTipY,
                                    vx,
                                    vy,
                                    damage: weapon.damage,
                                    size: weapon.bulletSize,
                                    color: weapon.color,
                                    explosive: weapon.explosive || false,
                                    explosionRadius: weapon.explosionRadius,
                                    penetration: weapon.penetration
                                });
                            }

                            // Decrease ammo
                            if (weapon.ammo !== Infinity) {
                                if (weaponAmmo[currentWeapon] === undefined) {
                                    weaponAmmo[currentWeapon] = weapon.ammo;
                                }
                                weaponAmmo[currentWeapon]--;
                            }
                        } else {
                            // Out of ammo, switch to pistol
                            currentWeapon = 'pistol';
                        }
                    }
                }

                // Check pickup collision
                pickups.forEach(pickup => {
                    const dx = myPlayer.x - pickup.x;
                    const dy = myPlayer.y - pickup.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < Constants.PLAYER_SIZE + 15) {
                        // Only collect if we need it and haven't already sent
                        if (lastSentPickup.has(pickup.id)) return;

                        let canCollect = false;
                        if (pickup.type === 'health' && myPlayer.health < myPlayer.maxHealth) {
                            canCollect = true;
                        } else if (pickup.type === 'armor' && myPlayer.armor < myPlayer.maxArmor) {
                            canCollect = true;
                        } else if (pickup.type.startsWith('weapon_')) {
                            const weaponType = pickup.type.replace('weapon_', '');
                            // Collect if we don't have it OR if we need ammo refill
                            if (currentWeapon !== weaponType) {
                                // Drop current weapon (except pistol)
                                if (currentWeapon !== 'pistol') {
                                    const dropData = {
                                        id: 'weapon_drop_' + Date.now(),
                                        type: 'weapon_' + currentWeapon,
                                        x: myPlayer.x,
                                        y: myPlayer.y
                                    };
                                    send({
                                        type: 'dropAbility',
                                        pickup: dropData
                                    });
                                }
                                canCollect = true;
                            } else {
                                // Refill ammo for current weapon
                                const weapon = Constants.WEAPONS[weaponType];
                                if (weapon.ammo !== Infinity) {
                                    weaponAmmo[weaponType] = weapon.ammo;
                                    canCollect = true;
                                }
                            }
                        } else if (pickup.type.startsWith('ability_')) {
                            // Only collect if we don't have an ability
                            if (!currentAbility) {
                                const abilityType = pickup.type.replace('ability_', '');
                                currentAbility = abilityType;
                                const abilityNames = {
                                    bladeswirl: 'Blade Swirl',
                                    shield: 'Shield',
                                    grapple: 'Grapple Hook'
                                };
                                document.getElementById('abilityName').textContent = abilityNames[abilityType] || abilityType;
                                document.getElementById('abilityName').style.color = '#00ffff';
                                canCollect = true;
                            }
                        }

                        if (canCollect) {
                            send({ type: 'collectPickup', pickupId: pickup.id });
                            lastSentPickup.add(pickup.id);
                            setTimeout(() => lastSentPickup.delete(pickup.id), 500);
                        }
                    }
                });

                // Send update to server (only if position/angle changed)
                const now = Date.now();
                if (now - lastUpdate > UPDATE_RATE) {
                    const roundedX = Math.round(myPlayer.x);
                    const roundedY = Math.round(myPlayer.y);
                    const roundedAngle = Math.round(myPlayer.angle * 100) / 100;

                    // Only send if changed significantly
                    if (!myPlayer.lastSent ||
                        Math.abs(roundedX - myPlayer.lastSent.x) > 1 ||
                        Math.abs(roundedY - myPlayer.lastSent.y) > 1 ||
                        Math.abs(roundedAngle - myPlayer.lastSent.angle) > 0.05) {

                        pingStart = now;
                        send({
                            type: 'move',
                            x: roundedX,
                            y: roundedY,
                            angle: roundedAngle
                        });

                        myPlayer.lastSent = { x: roundedX, y: roundedY, angle: roundedAngle };
                    }
                    lastUpdate = now;
                }
            }

            // Update particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95; // Friction
                particle.vy *= 0.95;
                particle.life -= 0.02;
                particle.size *= 0.97;
                return particle.life > 0;
            });

            // Update bullets and check collisions
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Check obstacle collision
                for (const obs of obstacles) {
                    if (bullet.x >= obs.x && bullet.x <= obs.x + obs.width &&
                        bullet.y >= obs.y && bullet.y <= obs.y + obs.height) {

                        // Check if bullet has penetration (sniper)
                        if (bullet.penetration && bullet.penetration > 0) {
                            // Track penetration count
                            if (!bullet.penetrationCount) bullet.penetrationCount = 0;

                            // Only damage if we haven't hit this block before
                            if (!bullet.hitBlocks) bullet.hitBlocks = new Set();
                            if (!bullet.hitBlocks.has(obs.id)) {
                                bullet.hitBlocks.add(obs.id);
                                bullet.penetrationCount++;

                                // Send damage
                                if (bullet.playerId === playerId) {
                                    send({
                                        type: 'obstacleHit',
                                        obstacleId: obs.id,
                                        damage: bullet.damage
                                    });
                                }

                                // Create penetration particles
                                for (let i = 0; i < 2; i++) {
                                    particles.push({
                                        x: bullet.x,
                                        y: bullet.y,
                                        vx: (Math.random() - 0.5) * 4,
                                        vy: (Math.random() - 0.5) * 4,
                                        size: 2 + Math.random() * 2,
                                        life: 1.0,
                                        color: '#9c27b0'
                                    });
                                }

                                // Stop bullet if penetration limit reached
                                if (bullet.penetrationCount >= bullet.penetration) {
                                    bullet.hit = true;
                                    break;
                                }
                            }
                            // Continue bullet flight if still has penetration left
                            continue;
                        }

                        // Handle rocket explosion
                        if (bullet.explosive && bullet.playerId === playerId && !bullet.hitSent) {
                            const explosionRadius = bullet.explosionRadius || 150;
                            createExplosion(bullet.x, bullet.y, explosionRadius, 500, 100);
                            bullet.hitSent = true;
                        } else if (bullet.playerId === playerId && !bullet.hitSent) {
                            // Normal bullet damage
                            send({
                                type: 'obstacleHit',
                                obstacleId: obs.id,
                                damage: bullet.damage
                            });
                            bullet.hitSent = true;

                            // Create fewer debris particles to reduce lag
                            for (let i = 0; i < 3; i++) {
                                particles.push({
                                    x: bullet.x,
                                    y: bullet.y,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    size: 3 + Math.random() * 3,
                                    life: 1.0,
                                    color: '#00ffff'
                                });
                            }
                        }

                        bullet.hit = true;
                        break;
                    }
                }

                // Check if bullet hit any player (ONLY FOR MY BULLETS)
                if (bullet.playerId === playerId && !bullet.hit) {
                    Object.values(players).forEach(player => {
                        if (player.id !== playerId && !bullet.hit) {
                            // Skip if invulnerable
                            if (player.invulnerable && Date.now() < player.invulnerableUntil) {
                                return;
                            }

                            const dx = bullet.x - player.x;
                            const dy = bullet.y - player.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < Constants.PLAYER_SIZE + bullet.size) {
                                // Hit! Check if explosive
                                if (bullet.explosive) {
                                    const explosionRadius = bullet.explosionRadius || 150;
                                    createExplosion(bullet.x, bullet.y, explosionRadius, 500, 100);
                                } else {
                                    // Normal bullet damage
                                    send({
                                        type: 'bulletHit',
                                        bulletId: bullet.id,
                                        targetId: player.id,
                                        damage: bullet.damage
                                    });
                                }

                                // Mark bullet for removal
                                bullet.hit = true;
                            }
                        }
                    });
                }

                return !bullet.hit &&
                       bullet.x >= 0 && bullet.x <= Constants.MAP_WIDTH &&
                       bullet.y >= 0 && bullet.y <= Constants.MAP_HEIGHT;
            });

            // Update blade swirl ability (collision detection)
            if (abilityActive && currentAbility === 'bladeswirl' && myPlayer) {
                bladeAngle += 0.1; // Spin speed

                blades.forEach((blade, index) => {
                    const currentAngle = bladeAngle + blade.angle;
                    const bladeX = myPlayer.x + Math.cos(currentAngle) * blade.radius;
                    const bladeY = myPlayer.y + Math.sin(currentAngle) * blade.radius;

                    // Check blade collisions with obstacles
                    if (!blade.totalHits) blade.totalHits = 0;

                    obstacles.forEach(obs => {
                        const centerX = obs.x + obs.width / 2;
                        const centerY = obs.y + obs.height / 2;
                        const dx = bladeX - centerX;
                        const dy = bladeY - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < obs.width / 2 + 15) {
                            // Hit obstacle!
                            const now = Date.now();
                            if (!blade.lastObstacleHit) blade.lastObstacleHit = {};
                            if (!blade.lastObstacleHit[obs.id] || now - blade.lastObstacleHit[obs.id] > 200) {
                                send({
                                    type: 'obstacleHit',
                                    obstacleId: obs.id,
                                    damage: 20
                                });
                                blade.lastObstacleHit[obs.id] = now;
                                blade.totalHits++;

                                // If blade has hit 3 blocks, deactivate ability early
                                if (blade.totalHits >= 3) {
                                    abilityActive = false;
                                    blades = [];
                                    currentAbility = null;
                                    document.getElementById('abilityName').textContent = 'None';
                                    document.getElementById('abilityName').style.color = '#00ffff';
                                }
                            }
                        }
                    });

                    // Check blade collisions with other players (with cooldown to prevent spam)
                    Object.values(players).forEach(otherPlayer => {
                        if (otherPlayer.id !== playerId && otherPlayer.health > 0) {
                            const dx = bladeX - otherPlayer.x;
                            const dy = bladeY - otherPlayer.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < Constants.PLAYER_SIZE + 10) {
                                // Hit! Send damage (with 500ms cooldown per player)
                                const now = Date.now();
                                if (!blade.lastHit) blade.lastHit = {};
                                if (!blade.lastHit[otherPlayer.id] || now - blade.lastHit[otherPlayer.id] > 500) {
                                    if (ws && ws.readyState === WebSocket.OPEN) {
                                        ws.send(JSON.stringify({
                                            type: 'bulletHit',
                                            targetId: otherPlayer.id,
                                            damage: 30
                                        }));
                                        blade.lastHit[otherPlayer.id] = now;
                                    }
                                }
                            }
                        }
                    });
                });
            }

            // === RENDERING PHASE ===
            // All rendering is now handled by the Renderer class (Phase 2 refactoring)
            renderer.render({
                terrain,
                floors,
                obstacles,
                buildings,
                pickups,
                particles,
                bullets,
                players,
                myPlayer,
                playerId,
                currentTool,
                currentWeapon,
                toolSwingTime,
                toolSwingDuration: 300,
                blades,
                bladeAngle,
                abilityActive,
                currentAbility,
                fps,
                ping,
                minimapMinimized,
                isMobile
            });

            // Update UI
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
